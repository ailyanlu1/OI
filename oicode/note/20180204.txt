半夜了，2018/2/4
今天的总结
其实现在是2/5，看了一会儿Qizy学长的文件...深深的...膜拜...太恐怖了...
先不说这个
今天学了啥
说实话今天的效率挺低的..因为遇上了一个史诗级码力题...开车旅行。
倍增才学不到五分钟，就来这道题，也太变态了点..作为初学者表示强力谴责，到了现在都没做出来...算了也罢
先不说这个，先看看今天学长给的资料
苦逼了，之前没学过lca，只能现场无力yy。
看看第一个题
10^7的数据量，RMQ问题
之前听说了这种问题。蓝书上有个备注
// -------以上全是废话--------
1. 并查集的骚操作
之前总结过，这次大概是深刻了一点。
并查集能做的远远不止是这点。
对于跳跳的功能，并查集还是很完善的。
比如说这个
我们定义位置i, 它的father是father[i]
f[i]表示[i, father[i]]的最小值/最大值
然后在走动的时候路径压缩
今天和LR纠结了半天这道题...
在shadypi的帮助下解决了qwq...
先把区间排序，只能离线了，
不过要保证O(n)的复杂度...只能基数排序了。带个大常数至少保证了复杂度对不对qwq
第二点，拿第一次查询举例子
[2, 4]的值是2 3 1
那么我们把father[2] = 4;
father[3] = 4;
father[4] = 4;
定义c_i为i位置到father[i]的最小值
所以在在走的时候动态维护
其实自己在写这篇日记的时候也没有写过代码，到时候只能现场yy
2. 倍增lca，完全没懂，跳过（
3. st表的意义（举例子
st表相对于开车来说才是我今天最重要的意义之一...
因为开车本身没有涉及到很多倍增的东西。
##### 倍增的本质，就是利用任何整数都可以由二进制合成
的性质。和昨天前天总结的妙妙的快速幂由类似的意义。
倍增是O(n^2)枚举的最好方法
优化到O(nlogn)
并查集是“信息复用”的优化方法
优化到O(\alpha(n))
动态规划是指数级复杂度的优化方法
优化到以上的三种
#####
这道题还没做完，倍增这个的总结留到明天
明天的效率一定要高起来，这里留一个list










