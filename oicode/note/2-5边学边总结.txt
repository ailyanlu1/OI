// ------------------------------------------
说到排序动态加多个点
其实还可以并归排序
这可以算是信息复用？
并归排序的合并是把两个原本有序的数列合并起来
如果是两个完全无关的数列，其实也是可以合并的说
蛮好的方法哎嘿嘿
其实平衡树也可以
只是
哪个傻逼在联赛手写平衡树啊！
// ------------------------------------------
对了，倍增的用处不仅仅是这里的那一点
也不仅仅是st表那样递推的倍增
还有一点点二分的性质
如果满足的话，当前状态拓宽一倍
如果不满足的话，当前状态缩小至1/2
until -> 0
今天的那个context adxxxxxx就可以解了
具体实现还没想好...
// ------------------------------------------
关于k步最短路我有个脑洞
前天做了一个恰好k个的背包问题
定义的状态是f[k][j]
是选k个，j个2的最大值
同样的，可以转化一下SPFA的dist的状态
转化为dist[k][i]，选k个点到达i的最小值是
那么 转移的时候
dist[k][to] = min(dist[k - 1][to] + val, dist[k][to]);
当已经选择了k个的时候，就不选了，状态无法转移...dist[k][to] = ....
哎貌似可以做哎...
// ------------------------------------------
我忽略了一点很重要的
通常来说，需要用到倍增的时候不是枚举。而是可以信息复用的东西。
信息复用也可以用并查集来做，时间复杂度一个nlogn一个n
但是并查集的要求要高一些，很多情况不能用

