# 搜索

---

这里是一点搜索的总结：

​	Astar本质上是优先队列bfs+估价函数，k短路的估价函数是“当前节点到t的最短路”，还有一个是IDAstar的rotation game的“最多修改多少次”。

​	首先从SDOI2010的魔法猪学院来说吧，k短路本身的思路利用到设计状态，<dist, x>是到x的最小值，利用优先队列的性质，第一次pop$x = t$的时候求出的就是最短路，第二次求出的就是次短路。这个时候我们发现，本质上是从贪心来走，最短路不一定在贪心的路上，所以需要设计估价函数，这里的估价函数是“当前节点到t的距离”，这样可以避免了完全的贪心，优化算法速度。

​	然后从FULL TANK POJ3635说起。这道题本质上是dp，表层呈现为bfs，利用SPFA防止有环的DP。这道题的DP状态设计是很经典的，`f[i][j]`到k个城市，“剩余j”，“剩余”设计需要注意。关键如下。

```cpp
inline void solve(int c, int s, int e)
{
	priority_queue<status> pq;
	memset(b, 0x3f, sizeof(b));
	for (int i = 0; i <= n; ++i) vis[i].reset();
	b[s][0] = 0;
	
	pq.push(status(s, 0, 0));
	
	while(!pq.empty())
	{
		status curr = pq.top(); pq.pop();
		if(vis[curr.city][curr.oil]) continue;
		vis[curr.city][curr.oil] = 1;

		if(curr.city == e) { cout << curr.cost << endl; return; }
		if(curr.oil < c && !vis[curr.city][curr.oil + 1] && b[curr.city][curr.oil] + p[curr.city] < b[curr.city][curr.oil + 1])
		{
			pq.push(status(curr.city, curr.cost + p[curr.city], curr.oil + 1));
			b[curr.city][curr.oil + 1] = b[curr.city][curr.oil] + p[curr.city];
		}

		for (int i = 0; i < edges[curr.city].size(); ++i)
		{
			Edge &e = edges[curr.city][i];
			if(curr.oil >= e.val && !vis[e.to][curr.oil - e.val] && b[e.to][curr.oil - e.val] > curr.cost)
			{
				b[e.to][curr.oil - e.val] = curr.cost;
				pq.push(status(e.to, curr.cost, curr.oil - e.val));
			}
		}
	}
	cout << "impossible" << endl;
}
```

TODO: 
POJ1742
POJ1015
TYVJ1061
TYVJ1051

