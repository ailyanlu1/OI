动态规划的本质不在于是递推或是递归，也不需要纠结是不是内存换时间。

理解动态规划并不需要数学公式介入，只是完全解释清楚需要点篇幅…首先需要明白哪些问题不是动态规划可以解决的，才能明白为神马需要动态规划。不过好处时顺便也就搞明白了递推贪心搜索和动规之间有什么关系，以及帮助那些总是把动规当成搜索解的同学建立动规的思路。当然熟悉了之后可以直接根据问题的描述得到思路，如果有需要的话再补充吧。

动态规划是对于 某一类问题 的解决方法！！重点在于如何鉴定“某一类问题”是动态规划可解的而不是纠结解决方法是递归还是递推！

怎么鉴定dp可解的一类问题需要从计算机是怎么工作的说起…计算机的本质是一个状态机，内存里存储的所有数据构成了当前的状态，CPU只能利用当前的状态计算出下一个状态（不要纠结硬盘之类的外部存储，就算考虑他们也只是扩大了状态的存储容量而已，并不能改变下一个状态只能从当前状态计算出来这一条铁律）

当你企图使用计算机解决一个问题是，其实就是在思考如何将这个问题表达成状态（用哪些变量存储哪些数据）以及如何在状态中转移（怎样根据一些变量计算出另一些变量）。所以所谓的空间复杂度就是为了支持你的计算所必需存储的状态最多有多少，所谓时间复杂度就是从初始状态到达最终状态中间需要多少步！

太抽象了还是举个例子吧：

比如说我想计算第100个非波那契数，每一个非波那契数就是这个问题的一个状态，每求一个新数字只需要之前的两个状态。所以同一个时刻，最多只需要保存两个状态，空间复杂度就是常数；每计算一个新状态所需要的时间也是常数且状态是线性递增的，所以时间复杂度也是线性的。

上面这种状态计算很直接，只需要依照固定的模式从旧状态计算出新状态就行（a[i]=a[i-1]+a[i-2]），不需要考虑是不是需要更多的状态，也不需要选择哪些旧状态来计算新状态。对于这样的解法，我们叫递推。

非波那契那个例子过于简单，以至于让人忽视了阶段的概念，所谓阶段是指随着问题的解决，在同一个时刻可能会得到的不同状态的集合。非波那契数列中，每一步会计算得到一个新数字，所以每个阶段只有一个状态。想象另外一个问题情景，假如把你放在一个围棋棋盘上的某一点，你每一步只能走一格，因为你可以东南西北随便走，所以你当你同样走四步可能会处于很多个不同的位置。从头开始走了几步就是第几个阶段，走了n步可能处于的位置称为一个状态，走了这n步所有可能到达的位置的集合就是这个阶段下所有可能的状态。

现在问题来了，有了阶段之后，计算新状态可能会遇到各种奇葩的情况，针对不同的情况，就需要不同的算法，下面就分情况来说明一下：

假如问题有n个阶段，每个阶段都有多个状态，不同阶段的状态数不必相同，一个阶段的一个状态可以得到下个阶段的所有状态中的几个。那我们要计算出最终阶段的状态数自然要经历之前每个阶段的某些状态。

好消息是，有时候我们并不需要真的计算所有状态，比如这样一个弱智的棋盘问题：从棋盘的左上角到达右下角最短需要几步。答案很显然，用这样一个弱智的问题是为了帮助我们理解阶段和状态。某个阶段确实可以有多个状态，正如这个问题中走n步可以走到很多位置一样。但是同样n步中，有哪些位置可以让我们在第n+1步中走的最远呢？没错，正是第n步中走的最远的位置。换成一句熟悉话叫做“下一步最优是从当前最优得到的”。所以为了计算最终的最优值，只需要存储每一步的最优值即可，解决符合这种性质的问题的算法就叫贪心。如果只看最优状态之间的计算过程是不是和非波那契数列的计算很像？所以计算的方法是递推。

既然问题都是可以划分成阶段和状态的。这样一来我们一下子解决了一大类问题：一个阶段的最优可以由前一个阶段的最优得到。

如果一个阶段的最优无法用前一个阶段的最优得到呢？

什么你说只需要之前两个阶段就可以得到当前最优？那跟只用之前一个阶段并没有本质区别。最麻烦的情况在于你需要之前所有的情况才行。

再来一个迷宫的例子。在计算从起点到终点的最短路线时，你不能只保存当前阶段的状态，因为题目要求你最短，所以你必须知道之前走过的所有位置。因为即便你当前再的位置不变，之前的路线不同会影响你的之后走的路线。这时你需要保存的是之前每个阶段所经历的那个状态，根据这些信息才能计算出下一个状态！

每个阶段的状态或许不多，但是每个状态都可以转移到下一阶段的多个状态，所以解的复杂度就是指数的，因此时间复杂度也是指数的。哦哦，刚刚提到的之前的路线会影响到下一步的选择，这个令人不开心的情况就叫做有后效性。

刚刚的情况实在太普遍，解决方法实在太暴力，有没有哪些情况可以避免如此的暴力呢？

契机就在于后效性。

有一类问题，看似需要之前所有的状态，其实不用。不妨也是拿最长上升子序列的例子来说明为什么他不必需要暴力搜索，进而引出动态规划的思路。

假装我们年幼无知想用搜索去寻找最长上升子序列。怎么搜索呢？需要从头到尾依次枚举是否选择当前的数字，每选定一个数字就要去看看是不是满足“上升”的性质，这里第i个阶段就是去思考是否要选择第i个数，第i个阶段有两个状态，分别是选和不选。哈哈，依稀出现了刚刚迷宫找路的影子！咦慢着，每次当我决定要选择当前数字的时候，只需要和之前选定的一个数字比较就行了！这是和之前迷宫问题的本质不同！这就可以纵容我们不需要记录之前所有的状态啊！既然我们的选择已经不受之前状态的组合的影响了，那时间复杂度自然也不是指数的了啊！虽然我们不在乎某序列之前都是什么元素，但我们还是需要这个序列的长度的。所以我们只需要记录以某个元素结尾的LIS长度就好！因此第i个阶段的最优解只是由前i-1个阶段的最优解得到的，然后就得到了DP方程（感谢 

[@韩曦]()

所以一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！

每个阶段只有一个状态->递推；
每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；
每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；
每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划。

> 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到

这个性质叫做最优子结构；

> 而不管之前这个状态是如何得到的

这个性质叫做无后效性。

by [**什么是动态规划？动态规划的意义是什么？ - 王勐的回答**](http://www.zhihu.com/question/23995189/answer/35429905)



**动态规划中递推式的求解方法不是动态规划的本质。**

我曾经作为省队成员参加过NOI，保送之后也给学校参加NOIP的同学多次讲过动态规划，我试着讲一下我理解的**动态规划**，争取深入浅出。希望你看了我的答案，能够喜欢上动态规划。

*状态的定义*

*状态转移方程*的定义

> **dynamic programming** is a method for solving a complex problem by **breaking it down into a collection of simpler subproblems**.

动态规划是通过**拆分问题，**定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。
本题下的其他答案，大多都是在说递推的求解方法，但**如何拆分问题**，才是动态规划的核心。
而**拆分问题**，靠的就是**状态的定义**和**状态转移方程的定义**。

状态的定义？

首先想说大家千万不要被下面的数学式吓到，这里只涉及到了函数相关的知识。

> 给定一个数列，长度为N，
> 求这个数列的最长上升（递增）子数列（LIS）的长度.
> 以
> 1 7 2 8 3 4
> 为例。
> 这个数列的最长递增子数列是 1 2 3 4，长度为4；
> 次长的长度为3， 包括 1 7 8; 1 2 3 等.

要解决这个问题，我们首先要**定义这个问题**和这个问题的子问题。
有人可能会问了，题目都已经在这了，我们还需定义这个问题吗？需要，原因就是这个问题在字面上看，找不出子问题，而没有子问题，这个题目就没办法解决。

> 给定一个数列，长度为N，
> 设![F_{k}](https://www.zhihu.com/equation?tex=F_%7Bk%7D)为：以数列中第k项结尾的最长递增子序列的长度.
> 求![F_{1}..F_{N}](https://www.zhihu.com/equation?tex=F_%7B1%7D..F_%7BN%7D) 中的最大值.

显然，这个新问题与原问题等价。
而对于![F_{k}](https://www.zhihu.com/equation?tex=F_%7Bk%7D)来讲，![F_{1} .. F_{k-1}](https://www.zhihu.com/equation?tex=F_%7B1%7D+..+F_%7Bk-1%7D)都是![F_{k}](https://www.zhihu.com/equation?tex=F_%7Bk%7D)的子问题：因为以第k项结尾的最长递增子序列（下称LIS），包含着以第![1..k-1](https://www.zhihu.com/equation?tex=1..k-1)中某项结尾的LIS。

上述的新问题![F_{k}](https://www.zhihu.com/equation?tex=F_%7Bk%7D)也可以叫做状态，定义中的“![F_{k}](https://www.zhihu.com/equation?tex=F_%7Bk%7D)为数列中第k项结尾的LIS的长度”，就叫做对状态的定义。
之所以把![F_{k}](https://www.zhihu.com/equation?tex=F_%7Bk%7D)做“状态”而不是“问题” ，一是因为避免跟原问题中“问题”混淆，二是因为这个新问题是数学化定义的。

当然不是

> 给定一个数列，长度为N，
> 设![F_{i, k}](https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D)为：
> 在前i项中的，长度为k的最长递增子序列中，最后一位的最小值. ![1\leq k\leq N](https://www.zhihu.com/equation?tex=1%5Cleq+k%5Cleq+N).
> 若在前i项中，不存在长度为k的最长递增子序列，则![F_{i, k}](https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D)为正无穷.
> 求最大的x，使得![F_{N,x}](https://www.zhihu.com/equation?tex=F_%7BN%2Cx%7D)不为正无穷。

这个新定义与原问题的等价性也不难证明，请读者体会一下。
上述的![F_{i, k}](https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D)就是状态，定义中的“![F_{i, k}](https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D)为：在前i项中，长度为k的最长递增子序列中，最后一位的最小值”就是对状态的定义。

\2. 什么是**状态转移方程**？
上述状态定义好之后，状态和状态之间的关系式，就叫做**状态转移方程。**

> 设![F_{k}](https://www.zhihu.com/equation?tex=F_%7Bk%7D)为：以数列中第k项结尾的最长递增子序列的长度.

> ![F_{1} = 1](https://www.zhihu.com/equation?tex=F_%7B1%7D+%3D+1) （根据状态定义导出边界情况）
> ![F_{k}=max(F_{i}+1 | A_{k}>A_{i}, i\in (1..k-1)) ](https://www.zhihu.com/equation?tex=F_%7Bk%7D%3Dmax%28F_%7Bi%7D%2B1+%7C+A_%7Bk%7D%3EA_%7Bi%7D%2C+i%5Cin+%281..k-1%29%29+)![(k>1)](https://www.zhihu.com/equation?tex=%28k%3E1%29)

用文字解释一下是：
以第k项结尾的LIS的长度是：保证第i项比第k项小的情况下，以第i项结尾的LIS长度加一的最大值，取遍i的所有值（i小于k）。

> 设![F_{i, k}](https://www.zhihu.com/equation?tex=F_%7Bi%2C+k%7D)为：在数列前i项中，长度为k的递增子序列中，最后一位的最小值

> 若![A_{i}>F_{i-1,k-1}](https://www.zhihu.com/equation?tex=A_%7Bi%7D%3EF_%7Bi-1%2Ck-1%7D)则![F_{i,k}=min(A_{i},F_{i-1,k}) ](https://www.zhihu.com/equation?tex=F_%7Bi%2Ck%7D%3Dmin%28A_%7Bi%7D%2CF_%7Bi-1%2Ck%7D%29+)
> 否则：![F_{i,k}=F_{i-1,k} ](https://www.zhihu.com/equation?tex=F_%7Bi%2Ck%7D%3DF_%7Bi-1%2Ck%7D+)

（边界情况需要分类讨论较多，在此不列出，需要根据状态定义导出边界情况。）
大家套着定义读一下公式就可以了，应该不难理解，就是有点绕。

这里可以看出，这里的状态转移方程，就是定义了问题和子问题之间的关系。
可以看出，状态转移方程就是带有条件的递推式。

**3. 动态规划迷思**
本题下其他用户的回答跟动态规划都有或多或少的联系，我也讲一下与本答案的联系。

a. “缓存”，“重叠子问题”，“记忆化”：
这三个名词，都是在阐述递推式求解的技巧。以Fibonacci数列为例，计算第100项的时候，需要计算第99项和98项；在计算第101项的时候，需要第100项和第99项，这时候你还需要重新计算第99项吗？不需要，你只需要在第一次计算的时候把它记下来就可以了。
上述的需要再次计算的“第99项”，就叫“重叠子问题”。如果没有计算过，就按照递推式计算，如果计算过，直接使用，就像“缓存”一样，这种方法，叫做“记忆化”，这是递推式求解的技巧。这种技巧，通俗的说叫“花费空间来节省时间”。**都不是动态规划的本质，****不是动态规划的核心。**

b. “递归”：
递归是递推式求解的方法，连技巧都算不上。

c. "无后效性"，“最优子结构”：
上述的状态转移方程中，等式右边不会用到下标大于左边i或者k的值，这是"无后效性"的通俗上的数学定义，符合这种定义的状态定义，我们可以说它具有“最优子结构”的性质，在动态规划中我们要做的，就是找到这种“最优子结构”。
**在对状态和状态转移方程的定义过程中，满足“最优子结构”是一个隐含的条件（否则根本定义不出来）。对状态和“最优子结构”的关系的进一步解释，什么是动态规划？动态规划的意义是什么？ - 王勐的回答 写的很好，大家可以去读一下。**

需要注意的是，一个问题可能有多种不同的状态定义和状态转移方程定义，存在一个有后效性的定义，**\*不代表该问题不适用动态规划***。这也是其他几个答案中出现的逻辑误区：
动态规划方法要寻找符合“最优子结构“的状态和状态转移方程的定义**，**在找到之后，这个问题就可以以“记忆化地求解递推式”的方法来解决。而寻找到的定义，才是动态规划的本质。

有位答主说：

> 分治在求解每个子问题的时候，都要进行一遍计算
> 动态规划则存储了子问题的结果，查表时间为常数

这就像说多加辣椒的菜就叫川菜，多加酱油的菜就叫鲁菜一样，是存在误解的。



by [徐凯强 Andy](https://www.zhihu.com/people/xukq)

