#include <bits/stdc++.h>
using namespace std;
namespace EdmondsKarp
{
struct Edge
{
	int from, to, cap, flow;
	Edge() {}
	Edge(int fr, int t, int c, int f):
	from(fr), to(t), cap(c), flow(f)
	{}
};

const int inf = 1e9;
const int maxn = 10000;
vector<int> link[maxn];
vector<Edge> edges;
int a[maxn]; // 到当前可以更新的最小值
int in[maxn]; // 用来回溯的in值
queue<int> bfs;

inline void addedge(int from, int to, int cap, int flow)
{
	edges.push_back(Edge(from, to, cap, 0));
	edges.push_back(Edge(to, from, 0, 0));
	int size = edges.size();
	link[from].push_back(size - 2);
	link[to].push_back(size - 1);
}

inline int maxFlow(int s, int t)
{
	int flow = 0;
	for(;;) {
		memset(a, 0, sizeof(a));
		bfs.clear();
		bfs.push_back(s);
		a[s] = inf;
		while(!bfs.empty())
		{
			int curr = bfs.front();
			bfs.pop();

			for (int i = 0; i < link[curr].size(); ++i)
			{
				Edge &e = edges[link[curr][i]];

				if(a[e.to] == 0 && e.cap > e.flow)
				{
					in[e.to] = link[curr][i];
					a[e.to] = min(a[curr], e.cap - e.flow);
					bfs.push_back(e.to);
				}
			}
			if(a[t]) break;
		}
		if(!a[t]) break;
		for (int i = t; i != s; i = edges[in[i]].from)
		{
			edges[in[i]].flow += a[t];
			edges[in[i] ^ 1].flow -= a[t];
		}
		flow += a[t];
	}
	return flow;
}
}
int n, m, s, t;
int u, v, w;
int main()
{
	using namespace EdmondsKarp;
	n = read(), m = read(), s = read(), t = read();
	for (int i = 0; i < m; ++i)
	{
		u = read(), v = read(), w = read();
		addedge(u, v, w, 0);
	}
	cout << maxFlow(s, t) << endl;
}